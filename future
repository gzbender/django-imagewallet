Задачи версии iwall:

— Перевести хранение в базе на питоновский формат вресии 3.0:

— Перейти на полноценные представления форматов, вместо списка функций.

— Перестать бегать в файловую систему для проверки существования файла. Отдельный кеш в памяти под разную мету.

— Убрать из основного модуля все зависимости по pil. Если когда-нибудь удастся сделать реализацию на graphicsmagic, я буду только счастлив.

— Отдельные стораджи для оригинала и нагенерированного.

— Не падать, если файлов нет.

— Более атомарные фильтры.


Теперь подробнее.

Не смотря на то, что я собирался как можно больше информации хранить в базе данных, в последствии я понял, что эта система не жизнеспособна. Обновление базы при генерации превьюшек влечет очень много проблем: мы не можем полагаться на то, что у разработчика настроена очистка кешей при сохранении, в результате старые версии могут восстанавливаться из кешей. Кроме того, иногда есть необходимость в пергенерации превьюшек. Это становится нетривиальной задачей, если в базе хранится информация, что превьюшки есть, а на диске их уже нет.

Поэтому кардинально формат меняться не будет, но будет сокращен и переведен на новую нотацию str.format(). Т.е. "a/b/xxxx_{f}.{e};J" вместо текущего "a/b/xxxx_%(size)s.%(extension)s;JPEG". Это даст экономию 18 байт на зачение, что при нынешнем заполнении (≈ 50к записей) уже мегабайт памяти на воркер.

При создании поля imagewallet, сейчас для каждого формата задается список фильтров, через которые проходит изоражение. В конце этого списка может быть строка, 'jpeg' или 'png', отмечающая нужный тип файла, в который должен быть сохранен данный формат. Это красивое архитектурное решение (также известное, как «костыль»), позволяет с помошью фильтров выставлять некоторые опции изображения, которые явно не являются пререгативой фильтров. Сейас это выглядит так:
PHOTO_FORMATS = {
'list': [Filter('background', 'white'),
	Filter('convert', 'RGB'),
	Filter('resize', size=(155, 125), strict_size=True),
	Filter('quality', 85),
	'JPEG']
}
Очевидно, что в этом списке фильтров фильтром является только 'resize' и с большой натяжкой 'background'. Вместо этой вакханалии должно получиться примерно следующее:
PHOTO_FORMATS = {
	'list': imagewallet.ImageFormat([
			Filter('resize', size=(155, 125)),
			Filter('padding', size=(155, 125)),
		],
		file_type=('JPEG', 85), background='white', colorspace='RGB'),
}

Большая проблема производительности — для генерации урлов к картинкам приходится каждый раз спрашивать сторадж «а есть че», и если нет, генерировать. Для сравнения: с проверкой (которая, естественно говорит что картинки на месте) мы можем генерировать 4400 урлов в секунду, а без проверки — 28500. Причем, думаю, нужно стремиться к цифре в 60000 урлов. Но для этого, конечно, спрашивать нужно будет не стораджа, а кеш. При этом довольно очевидно, что это должен быть кеш в виде объекта в локальной памяти, потому что любой удаленный кеш будет медленнее даже запроса к файлу.

Фильтры. Сейчас написание еще одного фильтра ничем не проще написания самого первого. Хотя там много мест, которые можно объеденить, да и вообще можно выработать общую концепцию парсинга параметров, отвечающих за геометрию.


Что является одним хранилищем: текстовой шаблон имени файла и тип уже хранящегося там оригинального файла. Является ли отсутствие этих парамтров хранилищем? Видимо, нет.
Какие функции должно выполнять хранилище: давать доступ к пути, урлу и размеру изображения. Перегенерировать изображение, если по указанному урлу его еще нет.
Возможно, нужно вводить понятие окружения — набора форматов и стораджей. А возможно нужно конструировать типы под наборы форматов, и тогда два хранилища будут не иметь одно окружение, а будут одного типа. Сразу решается вопрос с populate_formats и методами get_xxx.


Есть сумасшедшая идея, как еще немного разогнать path_<format>: сейчас _get_path вызывается внутри замыкания лямбдой, принимающей self. Т.е. вызывается лямбда, вызывается _get_path с параметрами из замыкания. Но параметры могу принимать значения по-умолчанию. Идея в том, чтобы клонировать функцию _get_path (и _get_url) для каждого формата, оставляя одинаковый код и меняя параметры по-умолчанию.


Генерация изображений не из стандартных полей.
Появилась идея, как отвязаться от патернов и хранения в базе непонятной фигни вместо имени файл. Вариант первый:
Мы принимаем, что все сгенерированные превьюшки — хлам, который не стоит того, чтобы лежать рядом с исходными изображениями. Исходный изображения имеют нормальные имена, а остальные форматы складываются в какой-нибудь walletcache с именами sha1(имя файла)_{f}.{e} (заодно хакеры не скачают оригинал по сети). Дальше все зависит от происхождения картинки. Если она получена кошерным методом через object_from_image, то она прошла минимальные фильтры оригинального формата и её тип файла поддерживается браузерами. Можем смело отдавать такую картинку по сети через url_original. Если же это левак, поступивший из вне, то скорее всего мы сможем его открыть, но url_original уже должно давать исключение. Конечно, определение типа картинки не может и не должно происходить в рантайме. Это просто должны быть разные классы. Скажем, FileWallet и FieldWallet.
Второй вариант менее радикальный, но в нем больше различий между кошерными картинками и нет. Кошерные остаются с текущей реализацией, в базе по прежнему хранятся патерны и форматы оригинальных изображений. Класс не кошерных будет работать уже без патернов, реализуя все то, что описано выше.

Пикачу! Т.е. первый вариант, я выбираю тебя!

И опять учтены интересы не всех слоев населения. Попробуем перечислить:
1) «Хочу хранить превьюшкаи на другом сервере, у меня там халявный трафик». Решается использованием разных стораджей.
2) «У меня все разложено по папочкам с красивыми именами. Хочу чтобы превьюшки там же хранились». Класть в ту же папку, что и оригинал можно даже без патернов.
3) «Я не хочу чтобы хакеры стянули оригинальные картинки». Отдельный сторадж без доступа по сети?
4) «Не хочу, чтобы кто-то мог узнать оригинальное название картинок». Хэш или рандом, но сам тоже не узнаешь.
5) «Использую отдельно от полей, все картинки уже лежат на своем месте. Не хочу чтобы туда гадили превьюшками». Ок, для тебя отдельный валет с другими правилами формирования имен.

Итого:
Название оргиналов случайное, название сгенерированных: <оригинал>_<format>.<ext>
Первый чувак должен будет настроить сторадж для сгенерированных, третий для оригинальных. У пятого имена будут получаться из хэша и класться в отдельную папку.
